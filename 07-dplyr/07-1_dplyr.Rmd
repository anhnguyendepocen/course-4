---
title: "Manipulating Data with `dplyr`"
author: "PLSC 31101"
date: "Fall 2019"
output: html_document
---

```{r include=FALSE} 
# include any code here you don't want to show up in the document,
# e.g. package and dataset loading
library(dplyr)
library(tidyr)
library(kableExtra)
```

# Data transformation

## Introduction 

### `tidyverse`

> It is often said that 80% of data analysis is spent on the process of cleaning and preparing the data. (Dasu and Johnson, 2003)

For most applied researchers, data preparation usually involves 3 main steps.

1. ***Transforming*** data frames, e.g. filtering, summarizing, and conducting calculations across groups.
2. ***Tidying*** data into the appropriate format.
3. ***Merging*** or linking several datasets to create a bigger dataset.

The [`tidyverse`](https://www.tidyverse.org/) is a suite of packages designed specifically to help with these steps. These are by no means the only packages out there for data wrangling but they are increasingly popular for their readable, straightforward syntax and sensible default behaviors.

In this chapter we’re going to focus on how to use the `dplyr` package for data transformation tasks.

### Gapminder

For this unit, we'll be working with the "Gapminder" dataset, which is excerpt of the data available at Gapminder.org. For each of 142 countries, the data  provides values for life expectancy, GDP per capita, and population, every five years, from 1952 to 2007.

```{r}
gap <- read.csv("data/gapminder-FiveYearData.csv", stringsAsFactors = TRUE)
kable(head(gap))
```

### why `dplyr`?

So far, you’ve seen the basics of manipulating data frames, e.g. subsetting and basic calculations. For instance, we can use base R functions to calculate summary statistics across groups of observations, e.g., the mean GDP per capita within each region:

```{r}
mean(gap[gap$continent == "Africa", "gdpPercap"])
mean(gap[gap$continent == "Americas", "gdpPercap"])
mean(gap[gap$continent == "Asia", "gdpPercap"])
```

But this isn't ideal because it involves a fair bit of repetition. Repeating yourself will cost you time, both now and later, and potentially introduce some nasty bugs.

Luckily, the [`dplyr`](https://cran.r-project.org/web/packages/dplyr/dplyr.pdf) package provides a number of very useful functions for manipulating dataframes. These functions will save you time by reducing repetition. As an added bonus, you might even find the `dplyr` grammar easier to read.

Here we're going to cover 6 of the most commonly used functions as well as using pipes (`%>%`) to combine them.

1. `select()`
2. `filter()`
3. `group_by()`
4. `summarize()`
5. `mutate()`
6. `arrange()`

If you have have not installed this package earlier, please do so now:

```{r,eval=FALSE}
# not run
# install.packages('dplyr')
```

Now let's load the package:

```{r,message=FALSE}
library(dplyr)
```

## `dplyr` functions

### Select columns with `select`

Imagine that we just received the gapminder dataset, but are only interested in a few variables in it. We could use the `select()` function to keep only the variables we select.

```{r}
year_country_gdp <- select(gap, year, country, gdpPercap)
kable(head(year_country_gdp))
```

```{r}
knitr::include_graphics(path = "img/dplyr-fig1.png")
```

If we open up `year_country_gdp`, we'll see that it only contains the year, country and gdpPercap. This is equivalent to the base R subsetting function:

```{r}
year_country_gdp_base <- gap[,c("year", "country", "gdpPercap")]
kable(head(year_country_gdp))
```

But, as we will see, `dplyr` makes for much more readible, efficient code because of its *pipe* operator.

### The pipe

```{r}
knitr::include_graphics(path = "img/pipe.jpg")
```

Above, we used what's called 'normal' grammar, but the strengths of `dplyr` lie in combining several functions using *pipes*. Since the pipes grammar is unlike anything we've seen in R before, let's repeat what we've done above using pipes.

Above, we used what's called "normal" grammar, but the strengths of `dplyr` lie in combining several functions using *pipes*.

In typical base R code, a simple operation might be written like: 

```{r eval=F}
# NOT run
cupcakes <- bake(pour(mix(ingredients)))
```

A computer has no trouble understanding this and your cupcakes will be made just fine but a person has to read right to left to understand the order of operations  - the opposite of how most western languages are read - making it harder to  understand what is being done! 

To be more readable without pipes, we might break up this code into intermediate objects... 

```{r, eval = F}
## NOT run
batter <- mix(ingredients)
muffin_tin <- pour(batter)
cupcakes <- bake(muffin_tin)
```

but this can clutter our environment with a lot of variables that aren't very useful to us, and often are named very similar things (e.g. step, step1, step2...) which can lead to confusion and those hard-to-track-down bugs. 

#### Enter the pipe... {-}

The *pipe* makes it easier to read code because it lays out the operations left to right  so each line can be read like a line of a recipe for the perfect data frame! 

Pipes take the input on the left side of the `%>%` symbol and pass it in as the first argument to the function on the right side.

With pipes, our cupcake example might be written like:

```{r, eval=F}
## NOT run
cupcakes <- ingredients %>% 
  mix() %>% 
  pour() %>% 
  bake()
```

#### Tips for piping {-}

1. Remember though that you don't assign anything within the pipes - that is, you should not use <- inside the piped operation. Only use this at the beginning if you want to save the output.

2. Remember to add the pipe `%>%` at the end of each line involved in the piped operation. A good rule of thumb: RStudio will automatically indent lines of code that are part of a piped operation. If the line isn’t indented, it probably hasn't been added to the pipe. If you have an error in a piped operation, always check to make sure the pipe is connected as you expect.

3. In RStudio the hotkey for the pipe is Ctrl + Shift + M. 

#### `select` & Pipe (`%>%`) {-}

Since the pipe grammar is unlike anything we've seen in R before, let's repeat what 
we did above with the gapminder dataset using pipes:

```{r}
year_country_gdp <- gap %>% select(year, country, gdpPercap)
```

Let's walk through it step by step.
First, we summon the gapminder data frame and pass it on to the next step using the pipe symbol `%>%`.
The second step is the `select()` function. In this case we don't specify which data object we use in the call to `select()` since we've piped it in.

**Fun Fact**: There is a good chance you have encountered pipes before in the shell. In R, a pipe symbol is `%>%` while in the shell it is `|.` But the concept is the same!

### Filter rows with `filter`

Now let's say we're only interested in African countries. We can combine `select` and `filter` to select only the observations where `continent` is `Africa`.

```{r}
year_country_gdp_africa <- gap %>%
    filter(continent == "Africa") %>%
    select(year, country, gdpPercap)
```

As with last time, first we pass the gapminder dataframe to the `filter()` function, then we pass the filtered version of the gapminder dataframe to the `select()` function.

To clarify, both the `select` and `filter` functions subsets the data frame. The difference is that `select` extracts certain columns, while `filter` extracts certain rows.

 **Note:** The order of operations is very important in this case. If we used `select` first, filter would not be able to find the variable `continent` since we would have removed it in the previous step.

### Calculate across groups with `group_by`

A common task you'll encounter when working with data is running calculations on different groups within the data. For instance, what if we wanted to calculated the mean GDP per capita for each continent?

In base R, you would have to run the `mean()` function for each subset of data:

```{r}
mean(gap$gdpPercap[gap$continent == "Africa"])
mean(gap$gdpPercap[gap$continent == "Americas"])
mean(gap$gdpPercap[gap$continent == "Asia"])
mean(gap$gdpPercap[gap$continent == "Europe"])
mean(gap$gdpPercap[gap$continent == "Oceania"])
```

That's a lot of repetition! To make matters worse, what if we wanted to add these values to our original data frame as a new column? We would have to write something like this:

```{r}
gap$mean.continent.GDP <- NA
gap$mean.continent.GDP[gap$continent == "Africa"] <- mean(gap$gdpPercap[gap$continent == "Africa"])
gap$mean.continent.GDP[gap$continent == "Americas"] <- mean(gap$gdpPercap[gap$continent == "Americas"])
gap$mean.continent.GDP[gap$continent == "Asia"] <- mean(gap$gdpPercap[gap$continent == "Asia"])
gap$mean.continent.GDP[gap$continent == "Europe"] <- mean(gap$gdpPercap[gap$continent == "Europe"])
gap$mean.continent.GDP[gap$continent == "Oceania"] <- mean(gap$gdpPercap[gap$continent == "Oceania"])
```

You can see how this can get pretty tedious, especially if we want to calculate more complicated or refined statistics. We could use loops or apply functions, but these can be difficult, slow, or error-prone. 

#### split-apply-combine {-}

The abstract problem we're encountering here is know as "split-apply-combine":

```{r}
knitr::include_graphics(path = "img/splitapply.png")
```

We want to *split* our data into groups (in this case continents), *apply* some calculations on that group, then  *combine* the results together afterwards. 

Luckily, `dplyr` offers a much cleaner, straight-forward solution to this problem. 

First, let's remove the column we just made.

```{r}
gap <- gap %>% select(-mean.continent.GDP) # drop a column with - 
# OR
gap$mean.continent.GDP <- NULL
```

#### `group_by`{-}

We've already seen how `filter()` can help us select observations that meet certain criteria (in the above: `continent == "Africa"`). More helpful, however, is the `group_by()` function, which will essentially use every unique criteria that we could have used in `filter()`.

A `grouped_df` can be thought of as a `list` where each item in the `list` is a `data.frame` which contains only the rows that correspond to the a particular value `continent` (at least in the example above).

```{r}
knitr::include_graphics(path = "img/dplyr-fig2.png")
```

### Summerarize across groups with `summarize`

`group_by()` on its own is not particularly interesting. It's much more exciting used in conjunction with the `summarize()` function. 

This will allow use to create new variable(s) by applying transformations to variables in each of the continent-specific data frames.

In other words, using the `group_by()` function, we split our original data frame into multipl pieces, which we then apply summary functions to (e.g. `mean()` or `sd()`) within `summarize()`.

The output is a new data frame reduced in size, with one row per group.

```{r}
gdp_bycontinents <- gap %>%
    group_by(continent) %>%
    summarize(mean_gdpPercap = mean(gdpPercap))
kable(head(gdp_bycontinents))
```

```{r}
knitr::include_graphics(path = "img/dplyr-fig3.png")
```

That allowed us to calculate the mean gdpPercap for each continent. 

But it gets even better -- the function `group_by()` allows us to group by multiple variables. Let's group by `year` and `continent`.

```{r}
gdp_bycontinents_byyear <- gap %>%
    group_by(continent, year) %>%
    summarize(mean_gdpPercap = mean(gdpPercap))
kable(head(gdp_bycontinents_byyear))
```

That is already quite powerful, but it gets even better! You're not limited to defining 1 new variable in `summarize()`.

```{r}
gdp_pop_bycontinents_byyear <- gap %>%
    group_by(continent, year) %>%
    summarize(mean_gdpPercap = mean(gdpPercap),
              sd_gdpPercap = sd(gdpPercap),
              mean_pop = mean(pop),
              sd_pop = sd(pop))
kable(head(gdp_pop_bycontinents_byyear))
```

### Add new variables with `mutate`

What if we wanted to add these values to our original data frame instead of creating a new object?

For this, we can use the `mutate()` function, which is similar to `summarize()` except it creates new variables to the same dataframe that you pass into it.

```{r}
gapminder_with_extra_vars <- gap %>%
    group_by(continent, year) %>%
    mutate(mean_gdpPercap = mean(gdpPercap),
              sd_gdpPercap = sd(gdpPercap),
              mean_pop = mean(pop),
              sd_pop = sd(pop))
kable(head(gapminder_with_extra_vars))
```

We can use also use `mutate()` to create new variables prior to (or even after) summarizing information.

```{r}
gdp_pop_bycontinents_byyear <- gap %>%
    mutate(gdp_billion = gdpPercap*pop/10^9) %>%
    group_by(continent, year) %>%
    summarize(mean_gdpPercap = mean(gdpPercap),
              sd_gdpPercap = sd(gdpPercap),
              mean_pop = mean(pop),
              sd_pop = sd(pop),
              mean_gdp_billion = mean(gdp_billion),
              sd_gdp_billion = sd(gdp_billion))
kable(head(gdp_pop_bycontinents_byyear))
```

#### `mutate` vs. `summarize` {-}

It can be confusing to decide whether to use `mutate` or `summarize`. The key distinction is whether you want the output to have one row for each group or one row for each row in the original data frame:

  - `mutate`: creates new columns with as many rows as the original data frame
  - `summarize`: creates a data frame with as many rows as groups

Note that if you use an aggregation function such as `mean()` within `mutate()` without using `groupby()`, you'll simply do the summary over all the rows of the input data frame.

And if you use an aggregation function such as `mean()` within `summarize()` without using `groupby()`, you'll simply create an output data frame with one row (i.e., the whole input data frame is a single group).

### Arrange rows with `arrange`

As a last step, let's say we want to sort the rows in our data frame according to values in a certain column. We can use the `arrange()` function to do this. For instance, let's organize our rows by `year` (recent first), and then by `continent`. 

```{r}
gapminder_with_extra_vars <- gap %>%
    group_by(continent, year) %>%
    mutate(mean_gdpPercap = mean(gdpPercap),
              sd_gdpPercap = sd(gdpPercap),
              mean_pop = mean(pop),
              sd_pop = sd(pop)) %>%
    arrange(desc(year), continent)
kable(head(gapminder_with_extra_vars))
```

## `dplyr` and "non-standard evaluation"

You may run across the term "non-standard evaluation". The use of data frame variables without quotes around them is an example of this.

Why is this strange?

```{r, eval = FALSE}
gap %>% select(continent, year) %>% tail()
```

Compare it to:

```{r, eval = F}
gap[ , c('continent', 'year')]
gap[ , continent]
```

Because `continent` and `year` are not variables our current environment! dplyr does some fancy stuff behind the scenes to save us from typing the quotes.

This is fine if you have a data analysis workflow but if you want to write a function that, for example, selects an arbitrary set of columns, you'll run into trouble.

```{r, eval = F}
## here's a helper function that computes the mean of a variable, stratifying by a grouping variable
grouped_mean <- function(data, group_var, summary_var) {
  data %>%
    group_by(group_var) %>%
    summarise(mean = mean(summary_var))
}
gap %>% grouped_mean(continent, lifeExp)
gap %>% grouped_mean('continent', 'lifeExp')
```

See the `rlang` or `seplyr` packages for how one can deal with this problem in this context of using functions. 

## Challenges

1. Use dplyr to create a data frame containing the median `lifeExp` for each continent

2. Use dplyr to add a column to the gapminder dataset that contains the total population of the continent of each observation in a given year. For example, if the first observation is Afghanistan in 1952, the new column would contain the population of Asia in 1952. 

3. Use dplyr to: (a) add a column called `gdpPercap_diff` that contains the difference between the observation's `gdpPercap` and the mean `gdpPercap` of the continent in that year, (b) arrange the dataframe by the column you just created, in descending order (so that the relatively richest country/years are listed first)

**hint**: You might have to `ungoup()` before you `arrange()`.

#### Acknowledgments {-}

Some of these materials in this module were adapted from:

* [Software Carpentry](http://swcarpentry.github.io/r-novice-gapminder/))
* [R bootcamp at UC Berkeley](https://github.com/berkeley-scf/r-bootcamp-fall-2019)